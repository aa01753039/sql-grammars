# The root rule
root ::= sql-stmt-list

# SQL Statement List
sql-stmt-list ::= [ select-stmt  ] ([;] [ select-stmt  ])*


# With Clause
with-clause ::= WITH [ RECURSIVE ] cte-table-name AS '(' select-stmt ')' 
    ( ',' cte-table-name AS '(' select-stmt ')' )*

# CTE Table Name
cte-table-name ::= table-name [ '(' column-name ( ',' column-name )* ')' ]

# Recursive CTE
recursive-cte ::= cte-table-name AS '(' initial-select ( UNION | UNION ALL ) 
    recursive-select ')'

# Common Table Expression
common-table-expression ::= table-name [ '(' column-name ( ',' column-name )* ')' ] 
    AS '(' select-stmt ')'


# Expression
expr ::= (
    literal-value | bind-parameter | [ [ database-name '.' ] table-name '.' ] 
    column-name | unary-operator expr | expr binary-operator expr | 
    function-name '(' [ [ DISTINCT ] expr ( ',' expr )* | '*' ] ')' | 
    '(' expr ')' | CAST '(' expr AS type-name ')' | expr COLLATE collation-name | 
    expr [ NOT ] ( LIKE | GLOB | REGEXP | MATCH ) expr [ ESCAPE expr ] | 
    expr ( ISNULL | NOTNULL | NOT NULL ) | expr IS [ NOT ] expr | 
    expr [ NOT ] BETWEEN expr AND expr | expr [ NOT ] IN 
    ( '(' [ select-stmt | expr ( ',' expr )* ] ')' | [ database-name '.' ] 
    table-name ) | [ [ NOT ] EXISTS ] '(' select-stmt ')' | CASE [ expr ] 
    WHEN expr THEN expr [ ELSE expr ] END | raise-function 
)


# Literal Value
literal-value ::= (
    numeric-literal | string-literal | blob-literal | NULL | 
    CURRENT_TIME | CURRENT_DATE | CURRENT_TIMESTAMP 
)

# Numeric Literal
numeric-literal ::= ( digit [ decimal-point ( digit )* ] | 
    decimal-point digit ) [ E [ '+' | '-' ] digit ]


# Pragma Statement
pragma-stmt ::= PRAGMA [ database-name '.' ] pragma-name [ '=' pragma-value | 
    '(' pragma-value ')' ]

# Pragma Value
pragma-value ::= ( signed-number | name | string-literal )



# Select Statement
select-stmt ::= [ WITH [ RECURSIVE ] common-table-expression 
    ( ',' common-table-expression )* ] (
    SELECT [ DISTINCT | ALL ] result-column ( ',' result-column )* 
    [ FROM ( table-or-subquery ( ',' table-or-subquery )* | join-clause ) ] 
    [ WHERE expr ] [ GROUP BY expr ( ',' expr )* [ HAVING expr ] ] | 
    VALUES '(' expr ( ',' expr )* ')' ( ',' '(' expr ( ',' expr )* )* 
) ( compound-operator ( SELECT [ DISTINCT | ALL ] result-column 
    ( ',' result-column )* [ FROM ( table-or-subquery ( ',' table-or-subquery )* 
    | join-clause ) ] [ WHERE expr ] [ GROUP BY expr 
    ( ',' expr )* [ HAVING expr ] ] | VALUES '(' expr ( ',' expr )* ')' 
    ( ',' '(' expr ( ',' expr )* )* ) )* [ ORDER BY ordering-term 
    ( ',' ordering-term )* ] [ LIMIT expr [ ( OFFSET | ',' ) expr ] ]

# Join Clause
join-clause ::= table-or-subquery [ join-operator table-or-subquery join-constraint ]

# Select Core
select-core ::= (
    SELECT [ DISTINCT | ALL ] result-column ( ',' result-column )* 
    [ FROM ( table-or-subquery ( ',' table-or-subquery )* | join-clause ) ] 
    [ WHERE expr ] [ GROUP BY expr ( ',' expr )* [ HAVING expr ] ] | 
    VALUES '(' expr ( ',' expr )* ')' ( ',' '(' expr ( ',' expr )* )* 
)

# Factored Select Statement
factored-select-stmt ::= [ WITH [ RECURSIVE ] common-table-expression 
    ( ',' common-table-expression )* ] select-core ( compound-operator 
    select-core )* [ ORDER BY ordering-term ( ',' ordering-term )* ] 
    [ LIMIT expr [ ( OFFSET | ',' ) expr ] ]

# Simple Select Statement
simple-select-stmt ::= [ WITH [ RECURSIVE ] common-table-expression 
    ( ',' common-table-expression )* ] select-core [ ORDER BY ordering-term 
    ( ',' ordering-term )* ] [ LIMIT expr [ ( OFFSET | ',' ) expr ] ]

# Compound Select Statement
compound-select-stmt ::= [ WITH [ RECURSIVE ] common-table-expression 
    ( ',' common-table-expression )* ] select-core ( UNION | UNION ALL | 
    INTERSECT | EXCEPT ) select-core [ ORDER BY ordering-term 
    ( ',' ordering-term )* ] [ LIMIT expr [ ( OFFSET | ',' ) expr ] ]

# Table Or Subquery
table-or-subquery ::= (
    [ database-name '.' ] table-name [ [ AS ] table-alias ] 
    [ INDEXED BY index-name | NOT INDEXED ] | '(' ( table-or-subquery 
    ( ',' table-or-subquery )* | join-clause ) ')' | '(' select-stmt ')' 
    [ [ AS ] table-alias ] 
)

# Result Column
result-column ::= (
    '*' | table-name '.' '*' | expr [ [ AS ] column-alias ] 
)

# Join Operator
join-operator ::= (
    ',' | [ NATURAL ] [ LEFT [ OUTER ] | INNER | CROSS ] JOIN 
)

# Join Constraint
join-constraint ::= [ ON expr | USING '(' column-name ( ',' column-name )* ')' ]

# Ordering Term
ordering-term ::= expr [ COLLATE collation-name ] [ ASC | DESC ]

# Compound Operator
compound-operator ::= (
    UNION | UNION ALL | INTERSECT | EXCEPT 
)


# Comment Syntax
comment-syntax ::= (
    '--' ( anything-except-newline )* ( newline | end-of-input ) | 
    '/*' ( anything-except-*/ )* ( '*/' | end-of-input ) 
)
