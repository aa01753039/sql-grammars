# Root rule specifies the overall pattern
root ::= select-stmt [;]?

# Select statement

select-stmt ::= (
    select-core (compound-operator subquery)* 
    ("ORDER" "BY" ordering-term ("," ordering-term)*)? 
    ("LIMIT" expr (("OFFSET" | ",") expr)?)?
)


# Common table expression
common-table-expression ::= table-name ("(" column-name ("," column-name)* ")")? "AS" "(" select-stmt ")"

# Compound operator
compound-operator ::= ("UNION" | "UNION" "ALL" | "INTERSECT" | "EXCEPT")

# Join clause
join-clause ::= table-or-subquery (join-operator table-or-subquery join-constraint)*

# Join operator
join-operator ::= ("," | "NATURAL"? ("LEFT" "OUTER"? | "INNER" | "CROSS")? "JOIN")

# Join constraint
join-constraint ::= ("ON" expr | "USING" "(" column-name ("," column-name)* ")")?

# Ordering term
ordering-term ::= expr ("COLLATE" collation-name)? ("ASC" | "DESC")? ("NULLS" ("FIRST" | "LAST"))?

# Result column
result-column ::= (expr ("AS"? column-alias)? | "*" | table-name "." "*")

# Table or subquery
table-or-subquery ::= (
    qualified-table-name 
    | (schema-name ".")? table-function-name "(" expr ("," expr)* ")" ("AS"? table-alias)? 
    | "(" (table-or-subquery ("," table-or-subquery)* | join-clause) ")" 
    | "(" select-stmt ")" ("AS"? table-alias)?
)

# Qualified table name
qualified-table-name ::= (schema-name ".")? table-name ("AS"? table-name)? ("INDEXED" "BY" index-name | "NOT" "INDEXED")?

# Window definition
window-defn ::= "(" base-window-name ("PARTITION" "BY" expr ("," expr)*)? ("ORDER" "BY" ordering-term ("," ordering-term)*)? frame-spec? ")"

# Frame specification
frame-spec ::= (
    ("RANGE" | "ROWS" | "GROUPS") 
    ("BETWEEN" 
        (("UNBOUNDED" | expr) "PRECEDING" 
        | "CURRENT" "ROW" 
        | expr "FOLLOWING")
        "AND"
        (("UNBOUNDED" | expr) "FOLLOWING" 
        | "CURRENT" "ROW" 
        | expr "PRECEDING")
    | ("UNBOUNDED" | expr) "PRECEDING" 
    | "CURRENT" "ROW")
    ("EXCLUDE" ("NO" "OTHERS" | "CURRENT" "ROW" | "GROUP" | "TIES") )?
)

# Expression
expr ::= (
    literal-value 
    | bind-parameter 
    | ( (schema-name ".")? table-name "." )? column-name 
    | unary-operator expr 
    | expr binary-operator expr 
    | function-name "(" ("DISTINCT"? expr ("," expr)* | "*")? ")" filter-clause? over-clause? 
    | "(" expr ("," expr)* ")" 
    | "CAST" "(" expr "AS" type-name ")" 
    | expr "COLLATE" collation-name 
    | expr "NOT"? ("LIKE" | "GLOB" | "REGEXP" | "MATCH") expr ("ESCAPE" expr)? 
    | expr ("ISNULL" | "NOTNULL" | "NOT" "NULL") 
    | expr "IS" "NOT"? expr 
    | expr "NOT"? "BETWEEN" expr "AND" expr 
    | expr "NOT"? "IN" ("(" (select-stmt | expr ("," expr)*) ")" | (schema-name ".")? (table-name | table-function "(" (expr ("," expr)*)? ")" ) ) 
    | ("NOT"? "EXISTS")? "(" select-stmt ")" 
    | "CASE" expr? ("WHEN" expr "THEN" expr)+ ("ELSE" expr)? "END" 
    | raise-function
)

# Raise function
raise-function ::= "RAISE" "(" ("IGNORE" | ("ROLLBACK" | "ABORT" | "FAIL") "," error-message) ")"

# Literal value
literal-value ::= (numeric-literal | string-literal | blob-literal | "NULL" | "TRUE" | "FALSE" | "CURRENT_TIME" | "CURRENT_DATE" | "CURRENT_TIMESTAMP")

# Numeric literal
numeric-literal ::= (digit+ (decimal-point digit*)? | decimal-point digit+) ("E" ("+" | "-")? digit+)? | "0x" hexdigit+

# Select core
select-core ::= (
    "SELECT" ("DISTINCT" | "ALL")? result-column ("," result-column)* 
    ("FROM" (table-or-subquery ("," table-or-subquery)* | join-clause) )? 
    ("WHERE" expr)? 
    ("GROUP" "BY" expr ("," expr)* ("HAVING" expr)? )? 
    ("WINDOW" window-name "AS" window-defn ("," window-name "AS" window-defn)* )? 
    | "VALUES" "(" expr ("," expr)* ")" ("," "(" expr ("," expr)* ")" )*
)
subquery::= (
    "SELECT" ("DISTINCT" | "ALL")? result-column ("," result-column)* 
    ("FROM" (table-or-subquery ("," table-or-subquery)* | join-clause) )? 
    ("WHERE" expr)? 
    ("GROUP" "BY" expr ("," expr)* ("HAVING" expr)? )? 
    ("WINDOW" window-name "AS" window-defn ("," window-name "AS" window-defn)* )? 
    | "VALUES" "(" expr ("," expr)* ")" ("," "(" expr ("," expr)* ")" )*
)

# Column name list
column-name-list ::= "(" column-name ("," column-name)* ")"

# Filter clause
filter-clause ::= "FILTER" "(" "WHERE" expr ")"

# Over clause
over-clause ::= "OVER" (window-name | window-defn)

